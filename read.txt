TIC TAC TOE
import random

def select_letter():
    let = ""
    auto_let = ""
    while(let != "x" and let != "o"):
        let = input("Select X or O: ").replace(" ", "").strip().lower()
    if let == "x":
        auto_let = "o"
    else:
        auto_let = "x"
    return let, auto_let

def clean_board():
    brd = [" " for x in range(10)]
    return brd

def is_board_full(board):
    return board.count(" ") == 0

def insert_letter(board, letter, pos):
    board[pos] = letter

def computer_move(board, letter):
    computer_letter = letter
    possible_moves = []
    available_corners = []
    available_edges = []
    available_center = []
    position = -1
    for i in range(1, len(board)):
        if board[i] == " ":
            possible_moves.append(i)
    for let in ["x", "o"]:
        for i in possible_moves:
            board_copy = board[:]
            board_copy[i] = let
            if is_winner(board_copy, let):
                position = i
    if position == -1:
        for i in range(len(board)):
            if board[i] == " ":
                if i in [1, 3, 7, 9]:
                    available_corners.append(i)
                if i == 5:
                    available_center.append(i)
                if i in [2, 4, 6, 8]:
                    available_edges.append(i)
        if len(available_corners) > 0:
            position = random.choice(available_corners)
        elif len(available_center) > 0:
            position = available_center[0]
        elif len(available_edges) > 0:
            position = random.choice(available_edges)
    board[position] = computer_letter

def draw_board(board):
    board[0] = -1
    print("   |   | ")
    print(" " + board[1] + " | " + board[2] + " | " + board[3] + " ")
    print("   |   | ")
    print("-" * 12)
    print("   |   | ")
    print(" " + board[4] + " | " + board[5] + " | " + board[6] + " ")
    print("   |   | ")
    print("-" * 12)
    print("   |   | ")
    print(" " + board[7] + " | " + board[8] + " | " + board[9] + " ")
    print("   |   | ")
    return board

def is_winner(board, letter):
    return (board[1] == letter and board[2] == letter and board[3] == letter) or \
           (board[4] == letter and board[5] == letter and board[6] == letter) or \
           (board[7] == letter and board[8] == letter and board[9] == letter) or \
           (board[1] == letter and board[4] == letter and board[7] == letter) or \
           (board[2] == letter and board[5] == letter and board[8] == letter) or \
           (board[3] == letter and board[6] == letter and board[9] == letter) or \
           (board[1] == letter and board[5] == letter and board[9] == letter) or \
           (board[3] == letter and board[5] == letter and board[7] == letter)

def repeat_game():
    repeat = input("Play again? Press y for yes and n for no: ")
    while repeat != "n" and repeat != "y":
        repeat = input("PLEASE, press y for yes and n for no: ")
    return repeat

def play_game():
    letter, auto_letter = select_letter()
    board = clean_board()
    board = draw_board(board)
    while is_board_full(board) == False:
        try:
            position = int(input("Select a position (1-9) to place an " + letter + " : "))
        except:
            position = int(input("PLEASE enter position using only NUMBERS from 1-9: "))
        if position not in range(1, 10):
            position = int(input("Please, choose another position to place an " + letter + " from 1 to 9 :"))
        if board[position] != " ":
            position = int(input("Please, choose an empty position to place an " + letter + " from 1 to 9: "))
        insert_letter(board, letter, position)
        computer_move(board, auto_letter)
        board = draw_board(board)
        if is_winner(board, letter):
            print("Congratulations! You Won.")
            return repeat_game()
        elif is_winner(board, auto_letter):
            print("Hard Luck! Computer won")
            return repeat_game()
        if is_board_full(board):
            print("Tie Game :)")
            return repeat_game()

    print("Welcome to Tic Tac Toe.")
    repeat = "y"
    while(repeat == "y"):
        repeat = play_game()

if __name__ == "__main__":
    play_game()













8 PUZZLE PROBLEM

import copy
from heapq import heappush, heappop

n = 3
row = [1, 0, -1, 0]
col = [0, -1, 0, 1]

class priorityQueue:
    def __init__(self):
        self.heap = []

    def push(self, k):
        heappush(self.heap, k)

    def pop(self):
        return heappop(self.heap)

    def empty(self):
        if not self.heap:
            return True
        else:
            return False

class node:
    def __init__(self, parent, mat, empty_tile_pos, cost, level):
        self.parent = parent
        self.mat = mat
        self.empty_tile_pos = empty_tile_pos
        self.cost = cost
        self.level = level

    def __lt__(self, nxt):
        return self.cost < nxt.cost

def calculateCost(mat, final) -> int:
    count = 0
    for i in range(n):
        for j in range(n):
            if ((mat[i][j]) and (mat[i][j] != final[i][j])):
                count += 1
    return count

def newNode(mat, empty_tile_pos, new_empty_tile_pos, level, parent, final) -> node:
    new_mat = copy.deepcopy(mat)
    x1 = empty_tile_pos[0]
    y1 = empty_tile_pos[1]
    x2 = new_empty_tile_pos[0]
    y2 = new_empty_tile_pos[1]
    new_mat[x1][y1], new_mat[x2][y2] = new_mat[x2][y2], new_mat[x1][y1]
    cost = calculateCost(new_mat, final)
    new_node = node(parent, new_mat, new_empty_tile_pos, cost, level)
    return new_node

def printMatrix(mat):
    for i in range(n):
        for j in range(n):
            print("%d " % (mat[i][j]), end=" ")
        print()

def isSafe(x, y):
    return x >= 0 and x < n and y >= 0 and y < n

def printPath(root):
    if root == None:
        return
    printPath(root.parent)
    printMatrix(root.mat)
    print()

def solve(initial, empty_tile_pos, final):
    pq = priorityQueue()
    cost = calculateCost(initial, final)
    root = node(None, initial, empty_tile_pos, cost, 0)
    pq.push(root)
    while not pq.empty():
        minimum = pq.pop()
        if minimum.cost == 0:
            printPath(minimum)
            return
        for i in range(n):
            new_tile_pos = [minimum.empty_tile_pos[0] + row[i], minimum.empty_tile_pos[1] + col[i]]
            if isSafe(new_tile_pos[0], new_tile_pos[1]):
                child = newNode(minimum.mat, minimum.empty_tile_pos, new_tile_pos, minimum.level + 1, minimum, final)
                pq.push(child)

initial = [
    [1, 2, 3],
    [5, 6, 0],
    [7, 8, 4]
]
final = [
    [1, 2, 3],
    [5, 8, 6],
    [0, 7, 4]
]
empty_tile_pos = [1, 2]
solve(initial, empty_tile_pos, final)






DEVELOPING AGENT PROBLEMS FOR REAL WORLD PROBLEMS

def vacuum_world():
    goal_state = {'A': '0', 'B': '0'}
    cost = 0
    location_input = input("Enter Location of Vacuum:")
    status_input = input("Enter status of " + location_input + ":")
    status_input_complement = input("Enter status of other room:")
    print("Initial Location Condition:" + str(goal_state))
    
    if location_input == 'A':
        print("Vacuum is placed in Location A")
        if status_input == '1':
            print("Location A is Dirty.")
            goal_state['A'] = '0'
            cost += 1
            print("Cost for CLEANING A " + str(cost))
            print("Location A has been Cleaned.")
        
        if status_input_complement == '1':
            print("Location B is Dirty.")
            print("Moving right to the Location B. ")
            cost += 1
            print("COST for moving RIGHT " + str(cost))
            goal_state['B'] = '0'
            cost += 1
            print("COST for SUCK " + str(cost))
            print("Location B has been Cleaned. ")
        else:
            print("No action " + str(cost))
            print("Location B is already clean.")
        
        if status_input == '0':
            print("Location A is already clean ")
        
        if status_input_complement == '1':
            print("Location B is Dirty.")
            print("Moving RIGHT to the Location B. ")
            cost += 1
            print("COST for moving RIGHT " + str(cost))
            goal_state['B'] = '0'
            cost += 1
            print("Cost for SUCK " + str(cost))
            print("Location B has been Cleaned. ")
        else:
            print("No action " + str(cost))
            print("Location B is already clean.")
    
    else:
        print("Vacuum is placed in location B")
        if status_input == '1':
            print("Location B is Dirty.")
            goal_state['B'] = '0'
            cost += 1
            print("COST for CLEANING " + str(cost))
            print("Location B has been Cleaned.")
        
        if status_input_complement == '1':
            print("Location A is Dirty.")
            print("Moving LEFT to the Location A. ")
            cost += 1
            print("COST for moving LEFT " + str(cost))
            goal_state['A'] = '0'
            cost += 1
            print("COST for SUCK " + str(cost))
            print("Location A has been Cleaned.")
        else:
            print("No action " + str(cost))
            print("Location A is already clean.")
        
        if status_input_complement == '1':
            print("Location A is Dirty.")
            print("Moving LEFT to the Location A. ")
            cost += 1
            print("COST for moving LEFT " + str(cost))
            goal_state['A'] = '0'
            cost += 1
            print("Cost for SUCK " + str(cost))
            print("Location A has been Cleaned. ")
        else:
            print("No action " + str(cost))
            print("Location A is already clean.")
    
    print("GOAL STATE: ")
    print(goal_state)
    print("Performance Measurement: " + str(cost))

vacuum_world()


INPUT  KAISE DENA H 
Enter Location of Vacuum:A
Enter status of A:0
Enter status of other room:1












IMPLEMENTATION AND ANALYSIS OF BFS FOR AN APPLICATION

import time as t
puzzle = []
solved = [1, 2, 3, 4, 5, 6, 7, 8, 0]

def zeroindex(puzzle):
    for i in range(9):
        if puzzle[i] == 0:
            return i
            break

def check(puzzle):
    count = 0
    for i in range(9):
        for j in range(i + 1, 9):
            if j == 9:
                break
            if puzzle[i] > puzzle[j] and puzzle[i] != 0 and puzzle[j] != 0:
                count += 1
    if not count % 2:
        return True
    else:
        return False

def heuristic(puzzle):
    man_dist = sum(abs((val - 1) % 3 - i % 3) + abs((val - 1) // 3 - i // 3) for i, val in enumerate(puzzle) if val)
    return man_dist

def min_heuristics(lists):
    min_val = min(lists)
    index = lists.index(min_val)
    return index

def machineplay(puzzle):
    openlist = []
    openLIST = []
    closedlist = []
    heuristicval = []
    openlist.append(puzzle)
    x = []
    x = openlist.pop(0)
    a = x[9]
    while x[:9] != solved:
        if a % 3 != 0:  # left
            statespace1 = x.copy()
            temp = statespace1[a]
            statespace1[a] = statespace1[a - 1]
            statespace1[a - 1] = temp
            statespace1[9] = a - 1
            statespace1.append("LEFT")
            if statespace1[:9] == solved:
                print("SOLVED!")
                print("The steps to solve are:- \n")
                print(", ".join(statespace1[10:]))
                break
            else:
                if statespace1[:9] not in closedlist and statespace1[:9] not in openLIST:
                    openlist.append(statespace1)  # for printing the steps
                    openLIST.append(statespace1[:9])  # to prevent loops
                    heuristicval.append(heuristic(statespace1[:9]))
        if a % 3 != 2:  # right
            statespace2 = x.copy()
            temp = statespace2[a]
            statespace2[a] = statespace2[a + 1]
            statespace2[a + 1] = temp
            statespace2[9] = a + 1
            statespace2.append("RIGHT")
            if statespace2[:9] == solved:
                print("SOLVED!")
                print("The steps to solve are:- \n")
                print(", ".join(statespace2[10:]))
                break
            else:
                if statespace2[:9] not in closedlist and statespace2[:9] not in openLIST:
                    openlist.append(statespace2)
                    openLIST.append(statespace2[:9])
                    heuristicval.append(heuristic(statespace2[:9]))
        if a != 0 and a != 1 and a != 2:  # up
            statespace3 = x.copy()
            temp = statespace3[a]
            statespace3[a] = statespace3[a - 3]
            statespace3[a - 3] = temp
            statespace3[9] = a - 3
            statespace3.append("UP")
            if statespace3[:9] == solved:
                print("SOLVED!")
                print("The steps to solve are:- \n")
                print(", ".join(statespace3[10:]))
                break
            else:
                if statespace3[:9] not in closedlist and statespace3[:9] not in openLIST:
                    openlist.append(statespace3)
                    openLIST.append(statespace3[:9])
                    heuristicval.append(heuristic(statespace3[:9]))
        if a != 6 and a != 7 and a != 8:  # down
            statespace4 = x.copy()
            temp = statespace4[a]
            statespace4[a] = statespace4[a + 3]
            statespace4[a + 3] = temp
            statespace4[9] = a + 3
            statespace4.append("DOWN")
            if statespace4[:9] == solved:
                print("\nSOLVED!")
                print("\nThe steps to solve are:- ")
                print(", ".join(statespace4[10:]))
                break
            else:
                if statespace4[:9] not in closedlist and statespace4[:9] not in openLIST:
                    openlist.append(statespace4)
                    openLIST.append(statespace4[:9])
                    heuristicval.append(heuristic(statespace4[:9]))
        closedlist.append(x[:9])
        y = min_heuristics(heuristicval)
        tem = heuristicval.pop(y)
        x = openlist.pop(y)
        a = x[9]

def show_board(puzzle):
    print("""
+---+---+---+
| {} | {} | {} |
+---+---+---+
| {} | {} | {} |
+---+---+---+
| {} | {} | {} |
+---+---+---
+""".format(*puzzle))

def enter_board():
    hmm = "n"
    while hmm == "n":
        print("\nEnter the board values with spaces: ")
        puzzle = list(map(int, input().split()))
        print("\nIs the following board correct?")
        show_board(puzzle)
        print('\n')
        hmm = input("[Y/N]: ").lower()
    return puzzle

puzzle = enter_board()
k = zeroindex(puzzle)
if check(puzzle):
    puzzle.append(k)

machineplay(puzzle)


OUTPUT YE DENA H 
Enter the board values with spaces: 
1 0 3 4 2 5 7 8 6
 Give yes i.e Y if asked 



IMPLEMENTATION AND ANALYSIS OF DFS FOR AN APPLICATION

from collections import defaultdict

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)
        
    def addEdge(self, u, v):
        self.graph[u].append(v)
        
    def DFSUtil(self, v, visited):
        visited.add(v)
        print(v, end=' ')
        for neighbour in self.graph[v]:
            if neighbour not in visited:
                self.DFSUtil(neighbour, visited)
                
    def DFS(self, v):
        visited = set()
        self.DFSUtil(v, visited)

g = Graph()
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 2)
g.addEdge(2, 0)
g.addEdge(2, 3)
g.addEdge(3, 3)

print("Following is DFS from (starting from vertex 2)")
g.DFS(2)



IMPLEMENTATION OF MINMAX ALGORITHM FOR AN APPLICATION

tree = [[[5, 1, 2], [8, -8, -9]], [[9, 4, 5], [-3, 4, 3]]]
root = 0
pruned = 0

def children(branch, depth, alpha, beta):
    global tree
    global root
    global pruned
    i = 0
    for child in branch:
        if type(child) is list:
            (nalpha, nbeta) = children(child, depth + 1, alpha, beta)
            if depth % 2 == 1:
                beta = nalpha if nalpha < beta else beta
            else:
                alpha = nbeta if nbeta > alpha else alpha
            branch[i] = alpha if depth % 2 == 0 else beta
            i += 1
        else:
            if depth % 2 == 0 and alpha < child:
                alpha = child
            if depth % 2 == 1 and beta > child:
                beta = child
            if alpha >= beta:
                pruned += 1
                break
    if depth == root:
        tree = alpha if root == 0 else beta
    return (alpha, beta)

def alphabeta(in_tree=tree, start=root, upper=-15, lower=15):
    global tree
    global pruned
    global root
    (alpha, beta) = children(tree, start, upper, lower)
    if __name__ == "__main__":
        print("(alpha, beta): ", alpha, beta)
        print("Result: ", tree)
        print("Times pruned: ", pruned)
    return (alpha, beta, tree, pruned)

if __name__ == "__main__":
    alphabeta(None)



IMPLEMENTATION OF UNIFICATION AND RESOLUTION FOR REAL WORLD

UNIFICATION
def unify(E1, E2):
    constants = [chr(i) for i in range(ord('a'), ord('w') + 1)]
    variables = [chr(i) for i in range(ord('A'), ord('Z') + 1)]
    variables.extend(['x', 'y', 'z'])
    
    if (E1 in constants and E2 in constants) or (E1 is None and E2 is None):  # base case
        if E1 == E2:
            return None
        else:
            return "FAIL"
    elif E1 in variables:
        if E1 in E2:
            return "FAIL - E1 occurs in E2"
        else:
            return (E2 + "/" + E1)
    elif E2 in variables:
        if E2 in E1:
            return "FAIL - E2 occurs in E1"
        else:
            return (E1 + "/" + E2)
    else:
        if ('(' in E1 and '(' not in E2):
            return "FAIL - E1 is a function and E2 is a variable/constant"
        elif ('(' not in E1 and '(' in E2):
            return "FAIL - E1 is a variable/constant and E2 is a function"

print("Enter the Expressions (without spaces):")
s1 = input()
s2 = input()
E1 = s1[2:len(s1)-1].split(',')
E2 = s2[2:len(s2)-1].split(',')

if s1[0] != s2[0]:
    print("FAIL - Initial Predicate Symbols in E1 and E2 are not identical")
elif len(E1) != len(E2):
    print("FAIL - E1 and E2 have different number of arguments")
else:
    n = len(E1)
    s = []  # General Unifiers
    print(" ")
    for i in range(n):
        print("E1:", E1[i])
        print("E2:", E2[i])
        print("Result:", unify(E1[i],E2[i]))
        print(" ")
        if "FAIL" not in unify(E1[i],E2[i]):
            s.append(unify(E1[i],E2[i]))
    if len(s) == n:
        print("General Unifiers: { ", end = "")
        for i in range(len(s)):
            if i != len(s)-1:
                print(s[i] + ", ", end = "")
            else:
                print(s[i] + " }", end = "")

UNIFICATION KE 2 CODE H KOI BHI RUN KR LENA 

def unify(statement1, statement2):
    # Split statements into words
    words1 = statement1.split()
    words2 = statement2.split()

    # Initialize an empty substitution dictionary
    substitution = {}

    # Iterate over the words in both statements
    for word1, word2 in zip(words1, words2):
        # If a word in statement 2 is a variable, assign its value based on statement 1
        if word2.isalpha() and word2[0].isupper():
            substitution[word2] = word1
        # If words don't match and neither is a variable, unification is not possible
        elif word1 != word2:
            return None

    # Return the substitution dictionary
    return substitution

# Given statements
statement1 = "Moksha and Vineela are sisters"
statement2 = "X and Y are sisters"

# Unify statement 2 with statement 1
result = unify(statement1, statement2)

# Print the result
if result:
    print("The unification is successful. Substitution =", result)
else:
    print("Unification failed.")



A* PROBLEM

from queue import PriorityQueue
class PuzzleState:
    def __init__(self, puzzle, parent=None, move="Initial", cost=0):
        self.puzzle = puzzle
        self.parent = parent
        self.move = move
        self.cost = cost
        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

    def __eq__(self, other):
        return self.puzzle == other.puzzle

    def __lt__(self, other):
        return self.cost < other.cost

    def __hash__(self):
        return hash(str(self.puzzle))

    def h(self):
        return sum([1 if self.puzzle[i][j] != self.goal_state[i][j] else 0 for i in range(3) for j in range(3)])

    def get_successors(self):
        successors = []
        empty_row, empty_col = self.find_empty_tile()
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        for dr, dc in directions:
            new_row, new_col = empty_row + dr, empty_col + dc
            if 0 <= new_row < 3 and 0 <= new_col < 3:
                new_puzzle = [row[:] for row in self.puzzle]
                new_puzzle[empty_row][empty_col], new_puzzle[new_row][new_col] = \
                    new_puzzle[new_row][new_col], new_puzzle[empty_row][empty_col]
                successors.append(PuzzleState(new_puzzle, self, "Move", self.cost + 1))

        return successors

    def find_empty_tile(self):
        for i in range(3):
            for j in range(3):
                if self.puzzle[i][j] == 0:
                    return i, j

def a_star_search(initial_state):
    frontier = PriorityQueue()
    frontier.put(initial_state)
    explored = set()

    while not frontier.empty():
        current_state = frontier.get()
        if current_state.puzzle == current_state.goal_state:
            return current_state

        explored.add(current_state)
        for successor in current_state.get_successors():
            if successor not in explored:
                frontier.put(successor)

    return None

def print_solution(solution):
    if solution is None:
        print("No solution found")
    else:
        path = []
        current_state = solution
        while current_state.parent:
            path.append((current_state.move, current_state.puzzle))
            current_state = current_state.parent
        path.append(("Initial", current_state.puzzle))

        path.reverse()
        for move, puzzle in path:
            print(move)
            print_puzzle(puzzle)

def print_puzzle(puzzle):
    for row in puzzle:
        print(row)
    print()

# Example usage:
initial_state = PuzzleState([[1, 2, 3], [4, 5, 6], [0, 7, 8]])
solution = a_star_search(initial_state)
print_solution(solution)



TOY PROBLEM
Camel Banana Problem

total_bananas = int(input("No. Of bananas at start : "))
distance = int(input("Distance to be covered  : "))
load_capacity = int(input("Maximum No. of bananas camel can carry at a time : "))

bananas_lost = 0
start = total_bananas
for i in range(distance) :
    while start > 0 :
        start = start-load_capacity
        if start == 1 :
            bananas_lost = bananas_lost-1
        bananas_lost = bananas_lost+2
    bananas_lost = bananas_lost-1
    start = total_bananas - bananas_lost
    if start == 0:
        break
print("Total bananas delivered : ", start )

OUTPUT YE DENA H 
No. Of bananas at start : 30
Distance to be covered  : 5
Maximum No. of bananas camel can carry at a time : 10
Total bananas delivered :  11


Water Jug Problem
def water_jug_problem(jug1_cap, jug2_cap, target_amount):
    # Initialize the jugs and the possible actions
    j1 = 0
    j2 = 0
    actions = [("fill", 1), ("fill", 2), ("empty", 1), ("empty", 2), ("pour", 1, 2), ("pour", 2, 1)]
    # Create an empty set to store visited states
    visited = set()
    # Create a queue to store states to visit
    queue = [(j1, j2, [])]
    while queue:
        # Dequeue the front state from the queue
        j1, j2, seq = queue.pop(0)
        # If this state has not been visited before, mark it as visited
        if (j1, j2) not in visited:
            visited.add((j1, j2))
            # If this state matches the target amount, return the sequence of actions taken to get to this state
            if j1 == target_amount:
                return seq
            # Generate all possible next states from this state
            for action in actions:
                if action[0] == "fill":
                    if action[1] == 1:
                        next_state = (jug1_cap, j2)
                    else:
                        next_state = (j1, jug2_cap)
                elif action[0] == "empty":
                    if action[1] == 1:
                        next_state = (0, j2)
                    else:
                        next_state = (j1, 0)
                else:
                    if action[1] == 1:
                        amount = min(j1, jug2_cap - j2)
                        next_state = (j1 - amount, j2 + amount)
                    else:
                        amount = min(j2, jug1_cap - j1)
                        next_state = (j1 + amount, j2 - amount)
                # Add the next state to the queue if it has not been visited before
                if next_state not in visited:
                    next_seq = seq + [action]
                    queue.append((next_state[0], next_state[1], next_seq))
    # If the queue becomes empty without finding a solution, return None
    return None

result = water_jug_problem(5, 3, 1)
print(result)



CONSTRAINT SATISFACTION PROBLEM

from itertools import combinations, permutations
def replacements():
    for comb in combinations(range(10), 8):
        for perm in permutations(comb):
            if perm[0] * perm[1] != 0:
                yield dict(zip('SENDMORY', perm))
a, b, c = 'SEND', 'MORE', 'MONEY'
for replacement in replacements():
    f = lambda x: sum(replacement[e] * 10**i for i, e in enumerate(x[::-1]))
    if f(a) + f(b) == f(c) and len(str(f(a)))==len(a) and len(str(f(b)))==len(b) and len(str(f(c)))==len(c):
        print('{} + {} = {}'.format(f(a), f(b), f(c)))

 To implement Bayesian Belief Networks to model the problem of Monty.
import random

def monty_hall_simulation(num_trials):
    switch_wins = 0
    stay_wins = 0

    for _ in range(num_trials):
        # print("")
        # print(f"{_} iteration ")
        doors = ['A', 'B', 'C']
        bike_location = random.choice(doors)
        # print("Bike location : ",bike_location)
        initial_choice = random.choice(doors)
        # print("player choice: ",initial_choice)
        doors.remove(initial_choice)

        if bike_location in doors:
            doors.remove(bike_location)
        monty_choice = random.choice(doors)

        # print("Monty's choice : ", monty_choice)
        doors = [d for d in ['A', 'B', 'C'] if d != monty_choice and d != initial_choice]
        final_choice = doors[0]

        stay_wins += (initial_choice == bike_location)
        switch_wins += (final_choice == bike_location)

    stay_win_prob = stay_wins / num_trials
    switch_win_prob = switch_wins / num_trials

    print(f"Probability of winning by staying: {stay_win_prob:.2f}")
    print(f"Probability of winning by switching: {switch_win_prob:.2f}")

# Number of trials
num_trials = 10000000

# Run simulation
monty_hall_simulation(num_trials)

Unsupervised Learning Methods
k means clustering
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans

x = [1,2,2,1,8,9,8,9]
y = [1,2,1,2,8,9,9,8]

plt.scatter(x,y)
plt.show()

data = list(zip(x,y))
inertias = []

for i in range(1,8):
  kmeans = KMeans(n_clusters=i)
  kmeans.fit(data)
  inertias.append(kmeans.inertia_)

plt.plot(range(1,8),inertias,marker="o")
plt.show()

kmeans = KMeans(n_clusters=2)
kmeans.fit(data)
plt.scatter(x,y,c=kmeans.labels_)
plt.show()


KNN
import matplotlib.pyplot as plt
from sklearn.neighbors import KNeighborsClassifier


x = [1,2,2,1,8,9,8,9]
y = [1,2,1,2,8,9,9,8]
classes = [0,0,0,0,1,1,1,1]
plt.scatter(x,y,c=classes)
plt.show()

data = list(zip(x,y))
knn = KNeighborsClassifier(n_neighbors=2)
knn.fit(data,classes)

new_x = 8.5
new_y = 8.5

new_point = [(new_x,new_y)]
prediction = knn.predict(new_point)
print(prediction)
import matplotlib.pyplot as plt
from sklearn.neighbors import KNeighborsClassifier


x = [1,2,2,1,8,9,8,9]
y = [1,2,1,2,8,9,9,8]
classes = [0,0,0,0,1,1,1,1]
plt.scatter(x,y,c=classes)
plt.show()

data = list(zip(x,y))
knn = KNeighborsClassifier(n_neighbors=2)
knn.fit(data,classes)

new_x = 8.5
new_y = 8.5

new_point = [(new_x,new_y)]
prediction = knn.predict(new_point)
print(prediction)


FUZZY LOGIC

# Difference Between Two Fuzzy Sets for A_key in A:  X[A_key]= 1-A[A_key] print('Fuzzy Set Complement is :', X)
A = dict() 
B = dict()
Y = dict() 
X = dict() 
A = {"a": 0.2, "b": 0.3, "c": 0.6, "d": 0.6} 
B = {"a": 0.9, "b": 0.9, "c": 0.4, "d": 0.5} 
print('The First Fuzzy Set is :', A)
print('The Second Fuzzy Set is :', B) 
for A_key, B_key in zip(A, B):         
    A_value = A[A_key]         
    B_value = B[B_key] 
    if A_value > B_value:                
        Y[A_key] = A_value
    else:                
            Y[B_key] = B_value 

print('Fuzzy Set Union is :', Y)


GRAPH COLORING

colors = ['red','blue','green','orange','yellow','violet']

states = ['MP','New Delhi','Haryana','Rajasthan','Gujarat']

neighbours = {
    'MP':['New Delhi','Rajasthan','Gujarat'],
    'New Delhi':['MP','Rajasthan','Haryana'],
    'Haryana':['New Delhi'],
    'Rajasthan':['MP','Gujarat','New Delhi'],
    'Gujarat':['Rajasthan','MP']
}

state_colors = {}
def promising(state, color):
    for neighbour in neighbours.get(state): 
        color_of_neighbor = state_colors.get(neighbour)
        if color_of_neighbor == color:
            return False

    return True
    
for state in states:
    for color in colors:
        if promising(state, color):
            state_colors[state] = color

print (state_colors)

ALPHA BETA PRUNING

MAX, MIN = 1000, -1000 
def minimax(depth, nodeIndex, maximizingPlayer, 
            values, alpha, beta): 

    if depth == 3: 
        return values[nodeIndex] 

    if maximizingPlayer: 
    
        best = MIN

        for i in range(0, 2): 
            
            val = minimax(depth + 1, nodeIndex * 2 + i, 
                        False, values, alpha, beta) 
            best = max(best, val) 
            alpha = max(alpha, best) 

            if beta <= alpha: 
                break
        
        return best 
    
    else: 
        best = MAX
        for i in range(0, 2): 
        
            val = minimax(depth + 1, nodeIndex * 2 + i, 
                            True, values, alpha, beta) 
            best = min(best, val) 
            beta = min(beta, best) 
            if beta <= alpha: 
                break
        
        return best 
    
if __name__ == "__main__": 

    values = []
    for i in range(0, 8):

        x = int(input(f"Enter Value {i}  : "))
        values.append(x)

    print ("The optimal value is :", minimax(0, 0, True, values, MIN, MAX)) 


OUTPUT- give any values between 1-9 when it asks for values

NLP

import nltk
nltk.download('vader_lexicon')

from nltk.sentiment.vader import SentimentIntensityAnalyzer

# Initialize the sentiment analyzer
sia = SentimentIntensityAnalyzer()

# Sample text for analysis
text = "I really enjoyed this movie. The acting was great and the plot was engaging."

# Calculate the sentiment score for the text
score = sia.polarity_scores(text)

# Print the sentiment score
print("negative = ", score["neg"])
print("neutral = ", score["neu"])
print("positive = ", score["pos"])
print("compound = ", score["compound"])
